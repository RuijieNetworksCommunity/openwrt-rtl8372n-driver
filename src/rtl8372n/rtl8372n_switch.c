#include <rtk_error.h>
#include <linux/kernel.h>
#include "rtl8372n_switch.h"
#include "rtl8372n_asicdrv.h"
#include "rtl8372n_asicdrv_vlan.h"
#include "rtl8372n_asicdrv_phy.h"
#include "rtl8372n_asicdrv_sds.h"

static init_state_t init_state = INIT_NOT_COMPLETED;


static rtk_switch_halCtrl_t rtl8373_hal_Ctrl =
{
    /* Switch Chip */
    CHIP_RTL8373,

    /* Logical to Physical */
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},

    /* Physical to Logical */
    {UTP_PORT0, UTP_PORT1, UTP_PORT2, UTP_PORT3, UTP_PORT4, UTP_PORT5, UTP_PORT6, UTP_PORT7, UTP_PORT8, UTP_PORT9},

    /* Port Type */
    {UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT},

    /* PTP port */
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},

    /* Valid port mask */
    (0x3FF),

    /* Valid UTP port mask */
    (0x3ff),

    /* Valid EXT port mask */
    (0x00),

    /* Valid CPU port mask */
    0x200,

    /* Minimum physical port number */
    0,

    /* Maxmum physical port number */
    9,

    /* Physical port mask */
    0x3ff,

    /* Combo Logical port ID */
    0,

    /* HSG Logical port ID */
    UTP_PORT1,

    /* SGMII Logical portmask */
    0x1,

    /* Max Meter ID */
    0x3f,

    /* MAX LUT Address Number */
    4160,

    /* Trunk Group Mask */
    0x0F
};

static rtk_switch_halCtrl_t *halCtrl = &rtl8373_hal_Ctrl;

struct PatchEntry16_2 {
    rtk_uint16 reg;
    rtk_uint16 val;
};

struct patch_entry16_4 {
    rtk_uint16 reg_addr;   // 要修改的寄存器地址
    rtk_uint16 end_bit;    // 位域结束位置 (高位)
    rtk_uint16 start_bit;  // 位域起始位置 (低位)
    rtk_uint16 value;      // 要写入的值
};

static const struct PatchEntry16_2 rst_smtr_patch_6818C_230703_patch[] = 
{
    {0xa436,0xa016},{0xa438,0x0},{0xa436,0xa012},{0xa438,0x0},{0xa436,0xa014},{0xa438,0x1800},{0xa438,0x8010},{0xa438,0x1800},{0xa438,0x8023},{0xa438,0x1800},{0xa438,0x8027},{0xa438,0x1800},{0xa438,0x802b},{0xa438,0x1800},{0xa438,0x8042},{0xa438,0x1800},{0xa438,0x8052},{0xa438,0x1800},{0xa438,0x8062},{0xa438,0x1800},{0xa438,0x8070},{0xa438,0x416e},{0xa438,0x1000},{0xa438,0x9cc},{0xa438,0x1000},{0xa438,0xa9b},{0xa438,0xd501},{0xa438,0xa103},{0xa438,0x8203},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x188},{0xa438,0x1000},{0xa438,0xaa1},{0xa438,0xd501},{0xa438,0x8103},{0xa438,0xa203},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x188},{0xa438,0xac03},{0xa438,0xa138},{0xa438,0x1800},{0xa438,0x1ded},{0xa438,0xac03},{0xa438,0xa138},{0xa438,0x1800},{0xa438,0x1cb8},{0xa438,0xd504},{0xa438,0xaa18},{0xa438,0xd500},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd719},{0xa438,0x7fac},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd704},{0xa438,0x5fbc},{0xa438,0xd504},{0xa438,0xa001},{0xa438,0xa1e0},{0xa438,0xd500},{0xa438,0xd031},{0xa438,0xd1c5},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd704},{0xa438,0x5fbc},{0xa438,0x1800},{0xa438,0x111f},{0xa438,0xbf80},{0xa438,0xd712},{0xa438,0x4077},{0xa438,0xd71e},{0xa438,0x4159},{0xa438,0xd4c0},{0xa438,0xd71e},{0xa438,0x6099},{0xa438,0x7f04},{0xa438,0x1800},{0xa438,0x1bc0},{0xa438,0x9f80},{0xa438,0x1800},{0xa438,0x1e2a},{0xa438,0x1800},{0xa438,0x1e2c},{0xa438,0xbf80},{0xa438,0xd712},{0xa438,0x4077},{0xa438,0xd71e},{0xa438,0x4159},{0xa438,0xd4c1},{0xa438,0xd71e},{0xa438,0x6099},{0xa438,0x7f04},{0xa438,0x1800},{0xa438,0x1bc0},{0xa438,0x9f80},{0xa438,0x1800},{0xa438,0x1cf6},{0xa438,0x1800},{0xa438,0x1cf9},{0xa438,0xd708},{0xa438,0x3b0f},{0xa438,0x8067},{0xa438,0x1800},{0xa438,0x150c},{0xa438,0xd503},{0xa438,0x8970},{0xa438,0xc07},{0xa438,0x901},{0xa438,0xa008},{0xa438,0x8002},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x1504},{0xa436,0xa026},{0xa438,0xffff},{0xa436,0xa024},{0xa438,0x1500},{0xa436,0xa022},{0xa438,0x1cec},{0xa436,0xa020},{0xa438,0x1e20},{0xa436,0xa006},{0xa438,0x1111},{0xa436,0xa004},{0xa438,0x1cb7},{0xa436,0xa002},{0xa438,0x1dec},{0xa436,0xa000},{0xa438,0x17f},{0xa436,0xa008},{0xa438,0x7f00},{0xa436,0xa012},{0xa438,0xff8},{0xa436,0xa014},{0xa438,0xc114},{0xa438,0xd04a},{0xa438,0xd069},{0xa438,0xd71f},{0xa438,0x40ff},{0xa436,0xa152},{0xa438,0xa20},{0xa436,0xa154},{0xa438,0x10f6},{0xa436,0xa156},{0xa438,0x122c},{0xa436,0xa158},{0xa438,0x9af},{0xa436,0xa15a},{0xa438,0x9b0},{0xa436,0xa150},{0xa438,0x1f},{0xFFFF,0xFFFF}
};

static const struct PatchEntry16_2 n2_patch_6818C_231206_patch[] = 
{
    {0xa436,0xa016},{0xa438,0x20},{0xa436,0xa012},{0xa438,0x0},{0xa436,0xa014},{0xa438,0x1800},{0xa438,0x8010},{0xa438,0x1800},{0xa438,0x801f},{0xa438,0x1800},{0xa438,0x8022},{0xa438,0x1800},{0xa438,0x8025},{0xa438,0x1800},{0xa438,0x8030},{0xa438,0x1800},{0xa438,0x8030},{0xa438,0x1800},{0xa438,0x8030},{0xa438,0x1800},{0xa438,0x8030},{0xa438,0xa301},{0xa438,0x1000},{0xa438,0xb55},{0xa438,0xd700},{0xa438,0x5f9f},{0xa438,0xd131},{0xa438,0xd047},{0xa438,0x1000},{0xa438,0xb55},{0xa438,0xd700},{0xa438,0x5edf},{0xa438,0xd700},{0xa438,0x5f74},{0xa438,0x1800},{0xa438,0x32a},{0xa438,0x8280},{0xa438,0x1800},{0xa438,0x504},{0xa438,0x9580},{0xa438,0x1800},{0xa438,0x74c},{0xa438,0x1000},{0xa438,0xb24},{0xa438,0xd14a},{0xa438,0xd048},{0xa438,0xd700},{0xa438,0x4014},{0xa438,0xd417},{0xa438,0x1000},{0xa438,0xb24},{0xa438,0x1800},{0xa438,0x670},{0xa436,0xa10e},{0xa438,0xffff},{0xa436,0xa10c},{0xa438,0xffff},{0xa436,0xa10a},{0xa438,0xffff},{0xa436,0xa108},{0xa438,0xffff},{0xa436,0xa106},{0xa438,0x66e},{0xa436,0xa104},{0xa438,0x74a},{0xa436,0xa102},{0xa438,0x503},{0xa436,0xa100},{0xa438,0x325},{0xa436,0xa110},{0xa438,0xf},{0xa436,0xa012},{0xa438,0xff8},{0xa436,0xa014},{0xa438,0xd186},{0xa438,0xd04e},{0xa436,0xa164},{0xa438,0x49d},{0xa436,0xa166},{0xa438,0x49e},{0xa436,0xa162},{0xa438,0x3},{0xFFFF,0xFFFF}
};

static const struct PatchEntry16_2 uc2_patch_6818C_231206_patch[] = 
{
    {0xa436,0xa016},{0xa438,0x0},{0xa436,0xa012},{0xa438,0x0},{0xa436,0xa014},{0xa438,0x1800},{0xa438,0x8010},{0xa438,0x1800},{0xa438,0x8023},{0xa438,0x1800},{0xa438,0x8027},{0xa438,0x1800},{0xa438,0x802b},{0xa438,0x1800},{0xa438,0x8042},{0xa438,0x1800},{0xa438,0x8052},{0xa438,0x1800},{0xa438,0x8062},{0xa438,0x1800},{0xa438,0x8070},{0xa438,0x416e},{0xa438,0x1000},{0xa438,0x9cc},{0xa438,0x1000},{0xa438,0xa9b},{0xa438,0xd501},{0xa438,0xa103},{0xa438,0x8203},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x188},{0xa438,0x1000},{0xa438,0xaa1},{0xa438,0xd501},{0xa438,0x8103},{0xa438,0xa203},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x188},{0xa438,0xac03},{0xa438,0xa138},{0xa438,0x1800},{0xa438,0x1ded},{0xa438,0xac03},{0xa438,0xa138},{0xa438,0x1800},{0xa438,0x1cb8},{0xa438,0xd504},{0xa438,0xaa18},{0xa438,0xd500},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd719},{0xa438,0x7fac},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd704},{0xa438,0x5fbc},{0xa438,0xd504},{0xa438,0xa001},{0xa438,0xa1e0},{0xa438,0xd500},{0xa438,0xd031},{0xa438,0xd1c5},{0xa438,0x1000},{0xa438,0x14e4},{0xa438,0xd704},{0xa438,0x5fbc},{0xa438,0x1800},{0xa438,0x111f},{0xa438,0xbf80},{0xa438,0xd712},{0xa438,0x4077},{0xa438,0xd71e},{0xa438,0x4159},{0xa438,0xd4c0},{0xa438,0xd71e},{0xa438,0x6099},{0xa438,0x7f04},{0xa438,0x1800},{0xa438,0x1bc0},{0xa438,0x9f80},{0xa438,0x1800},{0xa438,0x1e2a},{0xa438,0x1800},{0xa438,0x1e2c},{0xa438,0xbf80},{0xa438,0xd712},{0xa438,0x4077},{0xa438,0xd71e},{0xa438,0x4159},{0xa438,0xd4c1},{0xa438,0xd71e},{0xa438,0x6099},{0xa438,0x7f04},{0xa438,0x1800},{0xa438,0x1bc0},{0xa438,0x9f80},{0xa438,0x1800},{0xa438,0x1cf6},{0xa438,0x1800},{0xa438,0x1cf9},{0xa438,0xd708},{0xa438,0x3b0f},{0xa438,0x8067},{0xa438,0x1800},{0xa438,0x150c},{0xa438,0xd503},{0xa438,0x8970},{0xa438,0xc07},{0xa438,0x901},{0xa438,0xa008},{0xa438,0x8002},{0xa438,0xd500},{0xa438,0x1800},{0xa438,0x1504},{0xa436,0xa026},{0xa438,0xffff},{0xa436,0xa024},{0xa438,0x1500},{0xa436,0xa022},{0xa438,0x1cec},{0xa436,0xa020},{0xa438,0x1e20},{0xa436,0xa006},{0xa438,0x1111},{0xa436,0xa004},{0xa438,0x1cb7},{0xa436,0xa002},{0xa438,0x1dec},{0xa436,0xa000},{0xa438,0x17f},{0xa436,0xa008},{0xa438,0x7f00},{0xa436,0xa012},{0xa438,0xff8},{0xa436,0xa014},{0xa438,0xc114},{0xa438,0xd04a},{0xa438,0xd069},{0xa438,0xd71f},{0xa438,0x40ff},{0xa436,0xa152},{0xa438,0xa20},{0xa436,0xa154},{0xa438,0x10f6},{0xa436,0xa156},{0xa438,0x122c},{0xa436,0xa158},{0xa438,0x9af},{0xa436,0xa15a},{0xa438,0x9b0},{0xa436,0xa150},{0xa438,0x1f},{0xa436,0xb87c},{0xa438,0x8592},{0xa436,0xb87e},{0xa438,0xaf85},{0xa438,0xaaaf},{0xa438,0x85b3},{0xa438,0xaf85},{0xa438,0xb9af},{0xa438,0x85bf},{0xa438,0xaf85},{0xa438,0xdeaf},{0xa438,0x85de},{0xa438,0xaf85},{0xa438,0xdeaf},{0xa438,0x85de},{0xa438,0x246},{0xa438,0xb802},{0xa438,0x3f92},{0xa438,0xaf21},{0xa438,0x102},{0xa438,0x85de},{0xa438,0xaf20},{0xa438,0xd202},{0xa438,0x8945},{0xa438,0xaf21},{0xa438,0x25f8},{0xa438,0xfbef},{0xa438,0x79fb},{0xa438,0xe080},{0xa438,0x12ad},{0xa438,0x2504},{0xa438,0xee83},{0xa438,0x8c00},{0xa438,0xd100},{0xa438,0xbf62},{0xa438,0xda02},{0xa438,0x5feb},{0xa438,0xffef},{0xa438,0x97ff},{0xa438,0xfcaf},{0xa438,0x4fe8},{0xa438,0xf8e0},{0xa438,0x8fff},{0xa438,0xa000},{0xa438,0x502},{0xa438,0x8602},{0xa438,0xae16},{0xa438,0xa001},{0xa438,0x502},{0xa438,0x869d},{0xa438,0xae0e},{0xa438,0xa002},{0xa438,0x502},{0xa438,0x8789},{0xa438,0xae06},{0xa438,0xa003},{0xa438,0x302},{0xa438,0x8832},{0xa438,0xfc04},{0xa438,0xf8f9},{0xa438,0xfafb},{0xa438,0xef79},{0xa438,0xfbbf},{0xa438,0x628f},{0xa438,0xe08f},{0xa438,0xd248},{0xa438,0x31a},{0xa438,0x9002},{0xa438,0x600a},{0xa438,0x1f55},{0xa438,0xe38f},{0xa438,0xd91c},{0xa438,0x450d},{0xa438,0x46e3},{0xa438,0x8fd8},{0xa438,0x1a43},{0xa438,0xe48f},{0xa438,0xd6e5},{0xa438,0x8fd7},{0xa438,0xef64},{0xa438,0x1f44},{0xa438,0x1f55},{0xa438,0xe38f},{0xa438,0xdbe1},{0xa438,0x8fd9},{0xa438,0x1c45},{0xa438,0xd46},{0xa438,0x1b64},{0xa438,0xe38f},{0xa438,0xd8ef},{0xa438,0x75e3},{0xa438,0x8fda},{0xa438,0x1a75},{0xa438,0x288},{0xa438,0xb7ef},{0xa438,0x47e4},{0xa438,0x8fdd},{0xa438,0xe58f},{0xa438,0xde1f},{0xa438,0x661f},{0xa438,0x55e0},{0xa438,0x8fd6},{0xa438,0xe18f},{0xa438,0xd7e3},{0xa438,0x8fdc},{0xa438,0x1a63},{0xa438,0xe38f},{0xa438,0xd91c},{0xa438,0x650d},{0xa438,0x661a},{0xa438,0x64bf},{0xa438,0x65ef},{0xa438,0xe08f},{0xa438,0xd248},{0xa438,0x31a},{0xa438,0x9002},{0xa438,0x600a},{0xa438,0xac2a},{0xa438,0x5d7},{0xa438,0x17f},{0xa438,0xae03},{0xa438,0xd700},{0xa438,0xff02},{0xa438,0x88c7},{0xa438,0xef47},{0xa438,0xe48f},{0xa438,0xdfe5},{0xa438,0x8fe0},{0xa438,0xee8f},{0xa438,0xff01},{0xa438,0xae03},{0xa438,0x222},{0xa438,0x14ff},{0xa438,0xef97},{0xa438,0xfffe},{0xa438,0xfdfc},{0xa438,0x4f8},{0xa438,0xf9fa},{0xa438,0xfbef},{0xa438,0x79fb},{0xa438,0x287},{0xa438,0x1abf},{0xa438,0x628f},{0xa438,0xe08f},{0xa438,0xd248},{0xa438,0x31a},{0xa438,0x9002},{0xa438,0x600a},{0xa438,0x1f55},{0xa438,0xe38f},{0xa438,0xd51b},{0xa438,0x45ab},{0xa438,0x24e0},{0xa438,0x8ffd},{0xa438,0xe18f},{0xa438,0xfee2},{0xa438,0x8fd3},{0xa438,0xe38f},{0xa438,0xd41b},{0xa438,0x45ab},{0xa438,0x14bf},{0xa438,0x8ffb},{0xa438,0x1f44},{0xa438,0x1f55},{0xa438,0xe18f},{0xa438,0xd8e3},{0xa438,0x8fda},{0xa438,0x1a45},{0xa438,0xdc19},{0xa438,0xddae},{0xa438,0x2ebf},{0xa438,0x8fe5},{0xa438,0xe38f},{0xa438,0xd24b},{0xa438,0x21a},{0xa438,0x93e8},{0xa438,0x8ffb},{0xa438,0x19e8},{0xa438,0x8ffc},{0xa438,0xd000},{0xa438,0xe18f},{0xa438,0xe2e2},{0xa438,0x8ffb},{0xa438,0xe38f},{0xa438,0xfc1a},{0xa438,0x54e0},{0xa438,0x8fdf},{0xa438,0xe18f},{0xa438,0xe01b},{0xa438,0x45aa},{0xa438,0x6ee},{0xa438,0x8fff},{0xa438,0x2ae},{0xa438,0x302},{0xa438,0x8927},{0xa438,0xffef},{0xa438,0x97ff},{0xa438,0xfefd},{0xa438,0xfc04},{0xa438,0xf8f9},{0xa438,0xef59},{0xa438,0xf9fa},{0xa438,0xfb02},{0xa438,0x6767},{0xa438,0xee8f},{0xa438,0xfb00},{0xa438,0xee8f},{0xa438,0xfc00},{0xa438,0xee8f},{0xa438,0xfd00},{0xa438,0xee8f},{0xa438,0xfe00},{0xa438,0xe08f},{0xa438,0xdfe1},{0xa438,0x8fe0},{0xa438,0xe28f},{0xa438,0xdde3},{0xa438,0x8fde},{0xa438,0xef74},{0xa438,0xef65},{0xa438,0xd55},{0xa438,0x288},{0xa438,0xfde7},{0xa438,0x8fd1},{0xa438,0xef46},{0xa438,0x1b47},{0xa438,0x9e29},{0xa438,0xef46},{0xa438,0x288},{0xa438,0xd4ad},{0xa438,0x2704},{0xa438,0x7cff},{0xa438,0xff14},{0xa438,0xe28f},{0xa438,0xfde3},{0xa438,0x8ffe},{0xa438,0x1b54},{0xa438,0x9e02},{0xa438,0xab0e},{0xa438,0xe48f},{0xa438,0xfde5},{0xa438,0x8ffe},{0xa438,0xef46},{0xa438,0xe48f},{0xa438,0xfbe5},{0xa438,0x8ffc},{0xa438,0x16ae},{0xa438,0xd1bf},{0xa438,0x63e2},{0xa438,0x266},{0xa438,0xd4ff},{0xa438,0xfefd},{0xa438,0xef95},{0xa438,0xfdfc},{0xa438,0x4f8},{0xa438,0xf9fa},{0xa438,0xfbef},{0xa438,0x79fb},{0xa438,0x267},{0xa438,0x67e2},{0xa438,0x8ffb},{0xa438,0xe38f},{0xa438,0xfce0},{0xa438,0x8fe2},{0xa438,0x1a50},{0xa438,0xe68f},{0xa438,0xf9e7},{0xa438,0x8ffa},{0xa438,0xd55},{0xa438,0x288},{0xa438,0xfde7},{0xa438,0x8fd1},{0xa438,0xe08f},{0xa438,0xf9e1},{0xa438,0x8ffa},{0xa438,0x288},{0xa438,0xd4ad},{0xa438,0x2704},{0xa438,0x7cff},{0xa438,0xff14},{0xa438,0x1f55},{0xa438,0xe38f},{0xa438,0xe11c},{0xa438,0x540d},{0xa438,0x54e0},{0xa438,0x8ffd},{0xa438,0xe18f},{0xa438,0xfe1b},{0xa438,0x54ab},{0xa438,0xfe0},{0xa438,0x8ff9},{0xa438,0xe18f},{0xa438,0xfa14},{0xa438,0xe48f},{0xa438,0xf9e5},{0xa438,0x8ffa},{0xa438,0xae22},{0xa438,0xbf8f},{0xa438,0xede3},{0xa438,0x8fd2},{0xa438,0x4b02},{0xa438,0x1a93},{0xa438,0xe88f},{0xa438,0xf919},{0xa438,0xe88f},{0xa438,0xfae0},{0xa438,0x8ff9},{0xa438,0xe18f},{0xa438,0xfae3},{0xa438,0x8fe2},{0xa438,0x1a43},{0xa438,0xe48f},{0xa438,0xf9e5},{0xa438,0x8ffa},{0xa438,0xef64},{0xa438,0xe08f},{0xa438,0xdfe1},{0xa438,0x8fe0},{0xa438,0x1b46},{0xa438,0xaba0},{0xa438,0xbf8f},{0xa438,0xede3},{0xa438,0x8fd2},{0xa438,0x4b02},{0xa438,0x1a93},{0xa438,0xd819},{0xa438,0xd9a4},{0xa438,0x0},{0xa438,0x302},{0xa438,0x8927},{0xa438,0xbf63},{0xa438,0xe202},{0xa438,0x66d4},{0xa438,0xee8f},{0xa438,0xff03},{0xa438,0xffef},{0xa438,0x97ff},{0xa438,0xfefd},{0xa438,0xfc04},{0xa438,0xf8f9},{0xa438,0xfafb},{0xa438,0xef79},{0xa438,0xfbbf},{0xa438,0x8fed},{0xa438,0xe38f},{0xa438,0xd24b},{0xa438,0x21a},{0xa438,0x93d8},{0xa438,0x19d9},{0xa438,0xe38f},{0xa438,0xd81b},{0xa438,0x43ef},{0xa438,0x740c},{0xa438,0x761f},{0xa438,0x44e1},{0xa438,0x8fd9},{0xa438,0xef64},{0xa438,0xd300},{0xa438,0x266},{0xa438,0xe6ef},{0xa438,0x47bf},{0xa438,0x8ff5},{0xa438,0xe38f},{0xa438,0xd21a},{0xa438,0x93dd},{0xa438,0xbf8f},{0xa438,0xede3},{0xa438,0x8fd2},{0xa438,0x4b02},{0xa438,0x1a93},{0xa438,0xd819},{0xa438,0xd9e3},{0xa438,0x8fd8},{0xa438,0x1b43},{0xa438,0xe38f},{0xa438,0xda1b},{0xa438,0x439f},{0xa438,0x1bbf},{0xa438,0x628f},{0xa438,0xe08f},{0xa438,0xd248},{0xa438,0x31a},{0xa438,0x9002},{0xa438,0x600a},{0xa438,0xbf8f},{0xa438,0xf5e2},{0xa438,0x8fd2},{0xa438,0x1a92},{0xa438,0xdb1b},{0xa438,0x31aa},{0xa438,0x1dd},{0xa438,0xee8f},{0xa438,0xff00},{0xa438,0xe08f},{0xa438,0xd210},{0xa438,0xe48f},{0xa438,0xd2a0},{0xa438,0x407},{0xa438,0xee8f},{0xa438,0xd200},{0xa438,0x222},{0xa438,0x14ff},{0xa438,0xef97},{0xa438,0xfffe},{0xa438,0xfdfc},{0xa438,0x4f8},{0xa438,0xfaac},{0xa438,0x4f08},{0xa438,0xef46},{0xa438,0x1b67},{0xa438,0xaa02},{0xa438,0xef74},{0xa438,0xfefc},{0xa438,0x4f8},{0xa438,0xfaef},{0xa438,0x461b},{0xa438,0x67ab},{0xa438,0x2ef},{0xa438,0x74fe},{0xa438,0xfc04},{0xa438,0xf9ef},{0xa438,0x95f9},{0xa438,0xef54},{0xa438,0xd55},{0xa438,0xe28f},{0xa438,0xd11b},{0xa438,0x239e},{0xa438,0x602},{0xa438,0x88fd},{0xa438,0xe78f},{0xa438,0xd15c},{0xa438,0x1f},{0xa438,0xbf64},{0xa438,0xb402},{0xa438,0x5feb},{0xa438,0xbf64},{0xa438,0xc002},{0xa438,0x600a},{0xa438,0xfdef},{0xa438,0x95fd},{0xa438,0x4f8},{0xa438,0xf9fb},{0xa438,0xef79},{0xa438,0xfbe2},{0xa438,0x8fd2},{0xa438,0xac3b},{0xa438,0xa5b},{0xa438,0x70c},{0xa438,0x321a},{0xa438,0x322b},{0xa438,0x40ae},{0xa438,0xa5b},{0xa438,0x30c},{0xa438,0x330c},{0xa438,0x211a},{0xa438,0x322b},{0xa438,0x6002},{0xa438,0x4756},{0xa438,0xffef},{0xa438,0x97ff},{0xa438,0xfdfc},{0xa438,0x4f8},{0xa438,0xef49},{0xa438,0xf8bf},{0xa438,0x8fed},{0xa438,0xe08f},{0xa438,0xd248},{0xa438,0x21a},{0xa438,0x90e8},{0xa438,0x8ffb},{0xa438,0x19e8},{0xa438,0x8ffc},{0xa438,0xee8f},{0xa438,0xff03},{0xa438,0xfcef},{0xa438,0x94fc},{0xa438,0x4ee},{0xa438,0x8fed},{0xa438,0xee},{0xa438,0x8fee},{0xa438,0xee},{0xa438,0x8fef},{0xa438,0xee},{0xa438,0x8ff0},{0xa438,0xee},{0xa438,0x8ff1},{0xa438,0xee},{0xa438,0x8ff2},{0xa438,0xee},{0xa438,0x8ff3},{0xa438,0xee},{0xa438,0x8ff4},{0xa438,0xee},{0xa438,0x8ff9},{0xa438,0xee},{0xa438,0x8ffa},{0xa438,0xee},{0xa438,0x8ffb},{0xa438,0xee},{0xa438,0x8ffc},{0xa438,0xee},{0xa438,0x8ffd},{0xa438,0xee},{0xa438,0x8ffe},{0xa438,0xee},{0xa438,0x8fd2},{0xa438,0xee},{0xa438,0x8fff},{0xa438,0xee},{0xa438,0x8fd1},{0xa438,0x4},{0xa436,0xb85e},{0xa438,0x20fe},{0xa436,0xb860},{0xa438,0x20cf},{0xa436,0xb862},{0xa438,0x2122},{0xa436,0xb864},{0xa438,0x4fdc},{0xa436,0xb886},{0xa438,0xffff},{0xa436,0xb888},{0xa438,0xffff},{0xa436,0xb88a},{0xa438,0xffff},{0xa436,0xb88c},{0xa438,0xffff},{0xa436,0xb838},{0xa438,0xf},{0xFFFF,0xFFFF},
};

static const struct PatchEntry16_2 uc_patch_6818C_221117_patch[] = 
{
    {0xa436,0x847d},{0xa438,0xaf84},{0xa438,0x95af},{0xa438,0x849a},{0xa438,0xaf84},{0xa438,0xa0af},{0xa438,0x84ae},{0xa438,0xaf84},{0xa438,0xdbaf},{0xa438,0x84fa},{0xa438,0xaf84},{0xa438,0xfaaf},{0xa438,0x84fa},{0xa438,0x2901},{0xa438,0xaf16},{0xa438,0x5802},{0xa438,0x84fa},{0xa438,0xaf16},{0xa438,0x2fee},{0xa438,0x8ffe},{0xa438,0xffee},{0xa438,0x8fff},{0xa438,0xffbf},{0xa438,0x161c},{0xa438,0xaf16},{0xa438,0xe2},{0xa438,0x8700},{0xa438,0xad30},{0xa438,0x21e2},{0xa438,0x8701},{0xa438,0xe387},{0xa438,0x21b},{0xa438,0x549f},{0xa438,0x17ef},{0xa438,0x54e1},{0xa438,0x8018},{0xa438,0xd14},{0xa438,0xbf85},{0xa438,0x8402},{0xa438,0x55a4},{0xa438,0xd11},{0xa438,0xbf85},{0xa438,0x8702},{0xa438,0x55a4},{0xa438,0xef45},{0xa438,0xe281},{0xa438,0xc2af},{0xa438,0x4056},{0xa438,0xe187},{0xa438,0xad},{0xa438,0x2813},{0xa438,0xe180},{0xa438,0x180d},{0xa438,0x16bf},{0xa438,0x8584},{0xa438,0x255},{0xa438,0xa40d},{0xa438,0x11bf},{0xa438,0x8587},{0xa438,0x255},{0xa438,0xa402},{0xa438,0x3b96},{0xa438,0xaf3a},{0xa438,0xfc02},{0xa438,0x8501},{0xa438,0x285},{0xa438,0x5904},{0xa438,0xf8f9},{0xa438,0xfafb},{0xa438,0xef79},{0xa438,0xfbd7},{0xa438,0x0},{0xa438,0xd500},{0xa438,0xa2},{0xa438,0x5},{0xa438,0xbf57},{0xa438,0x61ae},{0xa438,0x13a2},{0xa438,0x105},{0xa438,0xbf57},{0xa438,0x64ae},{0xa438,0xba2},{0xa438,0x205},{0xa438,0xbf57},{0xa438,0x67ae},{0xa438,0x3bf},{0xa438,0x576a},{0xa438,0x255},{0xa438,0xc3ef},{0xa438,0x6402},{0xa438,0x5b12},{0xa438,0x13e1},{0xa438,0x8ffb},{0xa438,0x1b13},{0xa438,0x9fd5},{0xa438,0xe083},{0xa438,0x7380},{0xa438,0x1b02},{0xa438,0x9f0a},{0xa438,0xef47},{0xa438,0xe48f},{0xa438,0xfce5},{0xa438,0x8ffd},{0xa438,0xae06},{0xa438,0x2a01},{0xa438,0xd300},{0xa438,0xaebd},{0xa438,0xffef},{0xa438,0x97ff},{0xa438,0xfefd},{0xa438,0xfc04},{0xa438,0xf8f9},{0xa438,0xfafb},{0xa438,0xe28f},{0xa438,0xfce3},{0xa438,0x8ffd},{0xa438,0xef65},{0xa438,0xe08f},{0xa438,0xfee1},{0xa438,0x8fff},{0xa438,0xef74},{0xa438,0x25a},{0xa438,0xf7ad},{0xa438,0x500c},{0xa438,0xe68f},{0xa438,0xfee7},{0xa438,0x8fff},{0xa438,0xe283},{0xa438,0x4ee6},{0xa438,0x834f},{0xa438,0xfffe},{0xa438,0xfdfc},{0xa438,0x4cc},{0xa438,0xc010},{0xa438,0xc0},{0xa438,0x2000},{0xa436,0xb818},{0xa438,0x164d},{0xa436,0xb81a},{0xa438,0x162c},{0xa436,0xb81c},{0xa438,0x15fd},{0xa436,0xb81e},{0xa438,0x4053},{0xa436,0xb850},{0xa438,0x3af9},{0xa436,0xb852},{0xa438,0x0},{0xa436,0xb878},{0xa438,0x0},{0xa436,0xb884},{0xa438,0x0},{0xa436,0xb832},{0xa438,0x1f},{0xFFFF,0xFFFF},
};

static const struct patch_entry16_4 RTCT_para_6818C_231206_patch[] = 
{
    {0xa436,0xf,0x0,0x81a3},{0xa436,0xf,0x0,0x81a3},{0xa438,0xf,0x8,0x32},{0xa436,0xf,0x0,0x81a4},{0xa438,0xf,0x8,0xc0},{0xa436,0xf,0x0,0x81a5},{0xa438,0xf,0x8,0x32},{0xa436,0xf,0x0,0x81a8},{0xa438,0xf,0x8,0x1d},{0xa436,0xf,0x0,0x81af},{0xa438,0xf,0x8,0x25},{0xa436,0xf,0x0,0x81b2},{0xa438,0xf,0x8,0x9},{0xa436,0xf,0x0,0x81b6},{0xa438,0xf,0x8,0x3f},{0xa436,0xf,0x0,0x81b7},{0xa438,0xf,0x8,0x48},{0xa436,0xf,0x0,0x81b8},{0xa438,0xf,0x8,0xc},{0xa436,0xf,0x0,0x81b9},{0xa438,0xf,0x8,0x4},{0xa436,0xf,0x0,0x81ba},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81bb},{0xa438,0xf,0x8,0x20},{0xa436,0xf,0x0,0x81bc},{0xa438,0xf,0x8,0x4},{0xa436,0xf,0x0,0x81bd},{0xa438,0xf,0x8,0x20},{0xa436,0xf,0x0,0x81be},{0xa438,0xf,0x8,0x1a},{0xa436,0xf,0x0,0x81bf},{0xa438,0xf,0x8,0xe0},{0xa436,0xf,0x0,0x81c0},{0xa438,0xf,0x8,0x1},{0xa436,0xf,0x0,0x81c1},{0xa438,0xf,0x8,0x3a},{0xa436,0xf,0x0,0x81c2},{0xa438,0xf,0x8,0x1c},{0xa436,0xf,0x0,0x81c3},{0xa438,0xf,0x8,0x60},{0xa436,0xf,0x0,0x81c4},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81c5},{0xa438,0xf,0x8,0x11},{0xa436,0xf,0x0,0x81c6},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81c7},{0xa438,0xf,0x8,0xcf},{0xa436,0xf,0x0,0x81c8},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81c9},{0xa438,0xf,0x8,0xb0},{0xa436,0xf,0x0,0x81ca},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81cb},{0xa438,0xf,0x8,0xf},{0xa436,0xf,0x0,0x81cc},{0xa438,0xf,0x8,0x11},{0xa436,0xf,0x0,0x81cd},{0xa438,0xf,0x8,0xc0},{0xa436,0xf,0x0,0x81ce},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81cf},{0xa438,0xf,0x8,0xe},{0xa436,0xf,0x0,0x81d0},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81d1},{0xa438,0xf,0x8,0xbe},{0xa436,0xf,0x0,0x81d2},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81d3},{0xa438,0xf,0x8,0x18},{0xa436,0xf,0x0,0x81d4},{0xa438,0xf,0x8,0x8},{0xa436,0xf,0x0,0x81d5},{0xa438,0xf,0x8,0x70},{0xa436,0xf,0x0,0x81d6},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81d7},{0xa438,0xf,0x8,0x37},{0xa436,0xf,0x0,0x81d8},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81d9},{0xa438,0xf,0x8,0x48},{0xa436,0xf,0x0,0x81da},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81db},{0xa438,0xf,0x8,0xf4},{0xa436,0xf,0x0,0x81dc},{0xa438,0xf,0x8,0xeb},{0xa436,0xf,0x0,0x81dd},{0xa438,0xf,0x8,0xa0},{0xa436,0xf,0x0,0x81de},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81df},{0xa438,0xf,0x8,0x2b},{0xa436,0xf,0x0,0x81e0},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81e1},{0xa438,0xf,0x8,0x9c},{0xa436,0xf,0x0,0x81e2},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81e3},{0xa438,0xf,0x8,0xb2},{0xa436,0xf,0x0,0x81e4},{0xa438,0xf,0x8,0xeb},{0xa436,0xf,0x0,0x81e5},{0xa438,0xf,0x8,0xaf},{0xa436,0xf,0x0,0x81e6},{0xa438,0xf,0x8,0x2},{0xa436,0xf,0x0,0x81e7},{0xa438,0xf,0x8,0x92},{0xa436,0xf,0x0,0x81e8},{0xa438,0xf,0x8,0xfe},{0xa436,0xf,0x0,0x81e9},{0xa438,0xf,0x8,0xe4},{0xa436,0xf,0x0,0x81ea},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81eb},{0xa438,0xf,0x8,0x3c},{0xa436,0xf,0x0,0x81ec},{0xa438,0xf,0x8,0x6},{0xa436,0xf,0x0,0x81ed},{0xa438,0xf,0x8,0xf2},{0xa436,0xf,0x0,0x81ee},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81ef},{0xa438,0xf,0x8,0x3a},{0xa436,0xf,0x0,0x81f0},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81f1},{0xa438,0xf,0x8,0x8a},{0xa436,0xf,0x0,0x81f2},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81f3},{0xa438,0xf,0x8,0xd0},{0xa436,0xf,0x0,0x81f4},{0xa438,0xf,0x8,0xa},{0xa436,0xf,0x0,0x81f5},{0xa438,0xf,0x8,0x9},{0xa436,0xf,0x0,0x81f6},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81f7},{0xa438,0xf,0x8,0xdc},{0xa436,0xf,0x0,0x81f8},{0xa438,0xf,0x8,0xff},{0xa436,0xf,0x0,0x81f9},{0xa438,0xf,0x8,0x30},{0xa436,0xf,0x0,0x81fa},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x8700},{0xa438,0xf,0x8,0x1},{0xa436,0xf,0x0,0x8701},{0xa438,0xf,0x8,0x4},{0xa436,0xf,0x0,0x8018},{0xa438,0xf,0x8,0x70},{0xa436,0xf,0x0,0x81a6},{0xa438,0xf,0x8,0xc0},{0xa436,0xf,0x0,0x81a9},{0xa438,0xf,0x8,0x0},{0xa436,0xf,0x0,0x81b0},{0xa438,0xf,0x8,0x5},{0xa436,0xf,0x0,0x81b3},{0xa438,0xf,0x8,0x1d},{0xa436,0xf,0x0,0x81fb},{0xa438,0xf,0x8,0x6c},{0xa436,0xf,0x0,0x8702},{0xa438,0xf,0x8,0x50},{0xFFFF,0xFFFF,0xFFFF,0xFFFF},
};

ret_t n0_patch_RL6818C_230703(rtk_uint32 port_mask)
{

    ret_t result = port_mask;
    const struct PatchEntry16_2 *patch_data = rst_smtr_patch_6818C_230703_patch;

    for (int port_index = 0; port_index != 8; ++port_index )
    {
        // 检查端口是否在端口掩码内
        while ( ((1 << port_index) & port_mask) == 0 )
        {
            if ( ++port_index == 8 ) return result;
        }
        rtk_uint32 patch_index = 0;
        // 应用所有补丁条目
        while(1)
        {
            if (patch_data[patch_index].reg != 0xFFFF && patch_data[patch_index].val != 0xFFFF) {
                break;
            }
            result = rtl8372n_phy_write(1 << port_index, 31, patch_data[patch_index].reg, patch_data[patch_index].val);
            if (result != RT_ERR_OK) return result;
            patch_index += 1; // 移动到下一个补丁条目
        }
    }
    return result;
}

ret_t n2_patch_6818C_231206(rtk_uint32 port_mask)
{

    ret_t result = port_mask;
    const struct PatchEntry16_2 *patch_data = n2_patch_6818C_231206_patch;

    for (int port_index = 0; port_index != 8; ++port_index )
    {
        // 检查端口是否在端口掩码内
        while ( ((1 << port_index) & port_mask) == 0 )
        {
            if ( ++port_index == 8 ) return result;
        }
        rtk_uint32 patch_index = 0;
        // 应用所有补丁条目
        while(1)
        {
            if (patch_data[patch_index].reg != 0xFFFF && patch_data[patch_index].val != 0xFFFF) {
                break;
            }
            result = rtl8372n_phy_write(1 << port_index, 31, patch_data[patch_index].reg, patch_data[patch_index].val);
            if (result != RT_ERR_OK) return result;
            patch_index += 1; // 移动到下一个补丁条目
        }
    }
    return result;
}

ret_t uc2_patch_6818C_231206(rtk_uint32 port_mask)
{

    ret_t result = port_mask;
    const struct PatchEntry16_2 *patch_data = uc2_patch_6818C_231206_patch;

    for (int port_index = 0; port_index != 8; ++port_index )
    {
        // 检查端口是否在端口掩码内
        while ( ((1 << port_index) & port_mask) == 0 )
        {
            if ( ++port_index == 8 ) return result;
        }
        rtk_uint32 patch_index = 0;
        // 应用所有补丁条目
        while(1)
        {
            if (patch_data[patch_index].reg != 0xFFFF && patch_data[patch_index].val != 0xFFFF) {
                break;
            }
            result = rtl8372n_phy_write(1 << port_index, 31, patch_data[patch_index].reg, patch_data[patch_index].val);
            if (result != RT_ERR_OK) return result;
            patch_index += 1; // 移动到下一个补丁条目
        }
    }
    return result;
}

ret_t uc_patch_6818C_221117(rtk_uint32 port_mask)
{

    ret_t result = port_mask;
    const struct PatchEntry16_2 *patch_data = uc_patch_6818C_221117_patch;

    for (int port_index = 0; port_index != 8; ++port_index )
    {
        // 检查端口是否在端口掩码内
        while ( ((1 << port_index) & port_mask) == 0 )
        {
            if ( ++port_index == 8 ) return result;
        }
        rtk_uint32 patch_index = 0;
        // 应用所有补丁条目
        while(1)
        {
            if (patch_data[patch_index].reg != 0xFFFF && patch_data[patch_index].val != 0xFFFF) {
                break;
            }
            result = rtl8372n_phy_write(1 << port_index, 31, patch_data[patch_index].reg, patch_data[patch_index].val);
            if (result != RT_ERR_OK) return result;
            patch_index += 1; // 移动到下一个补丁条目
        }
    }
    return result;
}

ret_t RTCT_para_6818C_231206(rtk_uint32 port_mask)
{

    ret_t result;
    const struct patch_entry16_4 *patch_data = RTCT_para_6818C_231206_patch;

    for (int port_index = 0; port_index != 8; ++port_index )
    {
        // 检查端口是否在端口掩码内
        while ( ((1 << port_index) & port_mask) == 0 )
        {
            if ( ++port_index == 8 ) return result;
        }
        rtk_uint32 patch_index = 0;
        // 应用所有补丁条目
        while(1){
            if (patch_data[patch_index].reg_addr == 0xFFFF && patch_data[patch_index].value == 0xFFFF) {
                break;
            }
            rtk_uint32 bit_offset = patch_data[patch_index].start_bit;
            rtk_uint32 bit_width = patch_data[patch_index].end_bit -patch_data[patch_index].start_bit + 1;
            rtk_uint32 bit_mask = 1 << bit_offset;
            if(bit_width != 1){
                bit_mask = ((1 << bit_width) - 1) << bit_offset;
            }

            result = rtl8372n_phy_regbits_write(1 << port_index, 31, patch_data[patch_index].reg_addr, bit_mask, patch_data[patch_index].value);
            if (result != RT_ERR_OK) return result;
            patch_index += 1; // 移动到下一个补丁条目
        }
    }
    return result;
}

ret_t data_ram_patch_6818C_221026(rtk_uint32 port_mask)
{
    ret_t result = port_mask;                          // 函数返回值

    // 定义关键寄存器地址
    const rtk_uint32 DATA_RAM_CTRL_REG = 0xB876; // 47254 (0xB876)
    const rtk_uint32 DATA_RAM_ADDR_REG = 0xB872; // 47250 (0xB872)
    
    // 定义全局变量地址
    const rtk_uint32 DATA_RAM_ADDRESS = 0xC206;
    const rtk_uint32 DATA_RAM_VALUE = 0xB1;

    // 遍历所有端口 (0-7)
    for (rtk_uint32 port_index = 0; port_index < 8; port_index++) {
        // 3.1 检查端口是否在掩码中
        if (!(port_mask & (1 << port_index))) continue;
        
        rtk_uint32 port_bit = 1 << port_index; // 端口位掩码
        
        // 3.2 禁用数据RAM访问 (47254[0]=0)
        rtl8372n_phy_regbits_write(port_bit, 31, DATA_RAM_CTRL_REG, 1, 0);
        
        // 3.3 清理地址寄存器高8位 (47250[15:8]=0)
        rtl8372n_phy_regbits_write(port_bit, 31, DATA_RAM_ADDR_REG, 0xFF00, 0);
        
        // 3.4 写入数据RAM
        data_ram_write_8b(port_index, DATA_RAM_ADDRESS, DATA_RAM_VALUE);
        
        // 3.5 启用数据RAM访问 (47254[0]=1)
        result = rtl8372n_phy_regbits_write(port_bit, 31, DATA_RAM_CTRL_REG, 1, 1);
    }
    
    return result;
}

ret_t afe_patch_6818C_220607(rtk_uint16 port_mask)
{
    // 步骤1: 定义关键寄存器地址
    const rtk_uint32 AFE_REG1 = 0xBF84; // 49028 (0xBF84)
    const rtk_uint32 AFE_REG2 = 0xBF8C; // 49036 (0xBF8C)
    
    // 步骤2: 定义位掩码和值
    const rtk_uint32 REG1_MASK = 0x7;   // 位掩码 (低3位)
    const rtk_uint32 REG1_VALUE = 4;    // 要写入的值
    const rtk_uint32 REG2_MASK = 0x7C0; // 位掩码 (位[10:6])
    const rtk_uint32 REG2_VALUE = 0;    // 要写入的值
    
    // 步骤3: 遍历所有端口 (0-7)
    for (int port_index = 0; port_index < 8; port_index++) {
        // 3.1 检查端口是否在掩码中
        if (!(port_mask & (1 << port_index))) {
        continue; // 跳过未选中的端口
        }
        
        rtk_uint32 port_bit = 1 << port_index; // 端口位掩码
        
        // 3.2 配置第一个AFE寄存器 (0xBF84)
        ret_t result = rtl8372n_phy_regbits_write(port_bit, 31, AFE_REG1, REG1_MASK, REG1_VALUE);
        if (result != RT_ERR_OK) return result;
        
        // 3.3 配置第二个AFE寄存器 (0xBF8C)
        result = rtl8372n_phy_regbits_write(port_bit, 31, AFE_REG2, REG2_MASK, REG2_VALUE);
        if (result != RT_ERR_OK) return result;
    }
    
    return RT_ERR_OK; // 成功
}

ret_t RL6818C_pwr_on_patch_phy_v008(rtk_uint32 port_mask)
{
    int port_index = 0;                          // 当前处理的端口索引
    ret_t result = RT_ERR_OK;                          // 函数返回值
    const int current_version = 8;               // 目标固件版本
    rtk_uint32 status_value;                    // 状态寄存器值
    rtk_uint32 rtct_status;                    // RTCT状态值
    rtk_uint32 fw_version;                      // 固件版本号

    // 遍历所有端口 (0-7)
    while (port_index < 8) {
        rtk_uint32 port_bit = 1 << port_index;    // 端口位掩码
        
        // 1.1 检查端口是否在掩码中且状态正常
        if ((port_mask & port_bit) && (uc1_sram_read_8b(port_index, 5) == 2)) {
        // 1.2 检查固件版本
            rtl8372n_phy_write(port_bit, 31, 0xA436, 0x801E);
            rtl8372n_phy_read(port_index, 31, 0xA438, &fw_version);

            // 1.3 如果版本不匹配则执行更新
            if (fw_version != current_version) {
                int retry;
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xB820, 0x10, 1);
                
                // 等待状态就绪 (最多30次重试)
                retry = 30;
                do {
                    rtl8372n_phy_regbits_read(port_index, 31, 0xB800, 0x40, &status_value);
                    if (status_value == 1) break;
                    retry--;
                } while (retry > 0);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA436, 0xFFFF, 0x8023);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA438, 0xFFFF, 0x1802);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA436, 0xFFFF, 0xB82E);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA438, 0xFFFF, 1);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xB820, 0x80, 1);
                
                // 应用功能补丁
                n0_patch_RL6818C_230703(port_bit);
                n2_patch_6818C_231206(port_bit);
                uc2_patch_6818C_231206(port_bit);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xB820, 0x80, 0);
                
                uc_patch_6818C_221117(port_bit);
                data_ram_patch_6818C_221026(port_bit);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA436, 0xFFFF, 0);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA438, 0xFFFF, 0);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xB82E, 1, 0);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA436, 0xFFFF, 0x8023);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA438, 0xFFFF, 0);
                
                rtl8372n_phy_regbits_write(port_bit, 31, 0xB820, 0x10, 0);
                
                // 2.11 等待状态空闲
                retry = 30;
                do {
                    rtl8372n_phy_regbits_read(port_index, 31, 0xB800, 0x40, &status_value);
                    if (status_value == 0) break;
                    retry--;
                } while (retry > 0);
                
                // 启用RTCT功能
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA4A0, 0x400, 1);
                
                // 等待RTCT就绪
                retry = 30;
                do {
                rtl8372n_phy_regbits_read(port_index, 31, 0xA600, 0xFF, &rtct_status);
                if (rtct_status == 1) break;
                retry--;
                } while (retry > 0);
                
                // 应用RTCT参数
                RTCT_para_6818C_231206(port_bit);
                
                // 配置SRAM
                uc1_sram_write_8b(port_index, 0x8FFB, 1);
                uc1_sram_write_8b(port_index, 0x80DC, 0xA);
                uc1_sram_write_8b(port_index, 0x8378, 0x22);
                
                // 配置PHY寄存器
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA47E, 0xC0, 1);
                
                // 配置更多SRAM
                uc2_sram_write_8b(port_index, 0x8217, 0x1E);
                uc2_sram_write_8b(port_index, 0x8384, 4);
                uc2_sram_write_8b(port_index, 0x8FD6, 0);
                uc2_sram_write_8b(port_index, 0x8FD7, 0);
                uc2_sram_write_8b(port_index, 0x8FD8, 0xC);
                uc2_sram_write_8b(port_index, 0x8FD9, 0x80);
                uc2_sram_write_8b(port_index, 0x8FDA, 0xA);
                uc2_sram_write_8b(port_index, 0x8FDB, 0x19);
                uc2_sram_write_8b(port_index, 0x8FDC, 0x19);
                uc2_sram_write_8b(port_index, 0x8FDD, 0);
                uc2_sram_write_8b(port_index, 0x8FDE, 0);
                uc2_sram_write_8b(port_index, 0x8FDF, 0);
                uc2_sram_write_8b(port_index, 0x8FE0, 0);
                uc2_sram_write_8b(port_index, 0x8FE1, 0x20);
                uc2_sram_write_8b(port_index, 0x8FE2, 0xC);
                uc2_sram_write_8b(port_index, 0x8FD3, 0);
                uc2_sram_write_8b(port_index, 0x8FD4, 0x15);
                uc2_sram_write_8b(port_index, 0x8FD5, 0x15);
                
                // 应用AFE补丁
                afe_patch_6818C_220607(port_bit);
                
                rtl8372n_phy_write(port_bit, 31, 0xA5D0, 0);
                rtl8372n_phy_regbits_write(port_bit, 31, 0xA428, 0x200, 0);
            }
        }
    // 处理下一个端口
    port_index++;
    }
    // 打印完成信息
    printk("RL6818C_pwr_on_patch_phy_v008 , patch 0x%x finished!\n", port_mask);
    return result;
}


ret_t RL6818C_pwr_on_patch_phy_v008_rls_lockmain(rtk_uint32 port_mask)
{
    ret_t result = port_mask;                          // 函数返回值
    const int current_version = 8;               // 目标固件版本
    // 步骤1: 定义关键寄存器地址
    const rtk_uint32 RTCT_CTRL_REG = 0xA4A0;   // 42144 (RTCT控制寄存器)
    const rtk_uint32 RTCT_STATUS_REG = 0xA600; // 42496 (RTCT状态寄存器)
    const rtk_uint32 FW_CTRL_REG = 0xA436;     // 42038 (固件控制寄存器)
    const rtk_uint32 FW_VERSION_REG = 0xA438;  // 42040 (固件版本寄存器)
    
    // 步骤2: 定义位掩码和常量
    const rtk_uint32 RTCT_ENABLE_MASK = 0x400; // 位10 (RTCT使能位)
    const rtk_uint32 RTCT_STATUS_MASK = 0xFF;  // 低8位 (RTCT状态位)
    const rtk_uint32 MAX_RETRY = 30;           // 最大重试次数
    const rtk_uint32 FW_CTRL_VALUE = 0x801E;   // 固件控制值
    
    // 步骤3: 遍历所有端口 (0-7)
    for (int port_index = 0; port_index < 8; port_index++) {
        // 3.1 检查端口是否在掩码中
        if (!(port_mask & (1 << port_index))) continue; // 跳过未选中的端口

        rtk_uint32 port_bit = 1 << port_index; // 端口位掩码
        
        // 3.2 禁用RTCT功能
        rtl8372n_phy_regbits_write(port_bit, 31, RTCT_CTRL_REG, RTCT_ENABLE_MASK, 0);
        
        // 3.3 等待RTCT状态空闲
        rtk_uint32 status_value;
        int retry_count = MAX_RETRY;
        do {
            // 读取RTCT状态
            rtl8372n_phy_regbits_read(port_index, 31, RTCT_STATUS_REG, RTCT_STATUS_MASK, &status_value);
            // 检查状态是否为1 (忙状态)
            if (status_value != 1) break;
            retry_count--;
        } while (retry_count > 0);
        
        // 3.4 恢复固件版本配置
        rtl8372n_phy_regbits_write(port_bit, 31, FW_CTRL_REG, 0xFFFF, FW_CTRL_VALUE);
        
        // 3.5 设置当前固件版本
        result = rtl8372n_phy_regbits_write(port_bit, 31, FW_VERSION_REG, 0xFFFF, current_version);
    }
    
    return result;
}

static rtk_api_ret_t _rtk_switch_init_8372n(void)
{
    rtk_uint32 init_state;

    rtl8372n_getAsicRegBits(0x7F60u, 3u, &init_state);
    if (init_state != 2) return RT_ERR_CHIP_NOT_SUPPORTED; //不知道该返回啥了
    
    // 关键寄存器配置
    rtl8372n_setAsicRegBits(0x6330u, 0x30000u, 0u);   // 0x6330[17:16] 清零
    rtl8372n_setAsicRegBits(0x6330u, 0xC0u, 0u);      // 0x6330[7:6] 清零
    rtl8372n_setAsicRegBits(0x6334u, 0xF0u, 0xFu);    // 0x6334[7:4] 置位 (1111)
    rtl8372n_setAsicRegBits(0x6454u, 0x7000u, 7u);    // 0x6454[14:12] 设置为7 (111)

    rtl8372n_sds_regbits_write(0, 0, 0, 0x200, 1);
    rtl8372n_sds_regbits_write(1, 0, 0, 0x200, 1);
    rtl8372n_sds_regbits_write(0, 6, 2, 0x2000, 1);
    rtl8372n_sds_regbits_write(1, 6, 2, 0x2000, 1);

    rtl8373_setAsicRegBits(0xA90, 0xF, 0xC);
    rtl8373_setAsicRegBits(0xA94, 0xFFFF, 0x596A);

    // 硬件复位序列
    fw_reset_flow_tgr(1);                       // 启动复位
    fw_reset_flow_tgr(0);                       // 完成复位

    // Disable PHYs for configuration
    rtl8372n_phy_write(0xF0u, 0x1fu, 0xA610u, 0x2858u);

    // Set bits 0x13 and 0x14 of 0x5fd4
	// r5fd4:0002914a R5fd4-001a914a
    rtl8372n_setAsicRegBits(0x5FD4u, 0x180000u, 3);

    // 端口寄存器配置 (地址范围: 0x1538-0x1B38, 步进256)
    rtk_uint32 base_addr = 0x1238u;
    for(rtk_uint32 port = 3;port < 9;port++){
        rtl8372n_setAsicRegBits(base_addr + (port * 0x100u), 0x10u, 1);// 设置当前地址的位4 (0x10)
        rtl8372n_setAsicRegBits(base_addr + (port * 0x100u), 0x100u, 1);// 设置当前地址的位8 (0x100)
        // rtl8372n_setAsicRegBits(base_addr + (port * 0x100u), 0x40, 0);
    }

    // r0b7c:000000d8 R0b7c-000000f8 r6040:00000030 R6040-00000031
    rtl8372n_setAsicRegBits(0x0B7Cu, 5u, 1);

    // 初始化寄存器块 (地址范围: 0x7124-0x714C, 步进4)
    rtk_uint32 reg_index = 0x7124u;
    do
    {
        rtl8372n_setAsicReg(reg_index, 0x1050u);// 写入固定值 0x1050
        reg_index += 4;                           // 步进4
    }
    while ( reg_index != 0x714C );               // 结束地址: 29004 (0x714C)

    //Clock register ?
    rtl8372n_setAsicRegBits(0x6040u, 1u, 1);

    RL6818C_pwr_on_patch_phy_v008(0xF0u);     // 应用电源管理补丁 (所有端口)
    RL6818C_pwr_on_patch_phy_v008_rls_lockmain(240LL);// 应用锁相环稳定性补丁 240ms

    // Re-enable PHY after configuration
    rtl8372n_phy_write(0xF0u, 0x1fu, 0xA610u, 0x2058u);

	// Enables MAC access
	// Set bits 0xc-0x14 of 0x632c to 0x1f8, see rtl8372_init
	// r632c:00000540 R632c-001f8540 // RTL8373: 001ff540
    rtl8372n_setAsicRegBits(0x632Cu, 0x1FF000u, 0x1F8u);
    return RT_ERR_OK;         
}

/* Function Name:
 *      rtk_switch_initialState_set
 * Description:
 *      Set initial status
 * Input:
 *      state   - Initial state;
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK       - Initialized
 *      RT_ERR_FAILED   - Uninitialized
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_initialState_set(init_state_t state)
{
    if(state >= INIT_STATE_END)
        return RT_ERR_FAILED;

    init_state = state;
    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_initialState_get
 * Description:
 *      Get initial status
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      INIT_COMPLETED     - Initialized
 *      INIT_NOT_COMPLETED - Uninitialized
 * Note:
 *
 */
init_state_t rtk_switch_initialState_get(void)
{
    return init_state;
}

/* Function Name:
 *      rtk_switch_probe
 * Description:
 *      Probe switch
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK       - Switch probed
 *      RT_ERR_FAILED   - Switch Unprobed.
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_probe(switch_chip_t *pSwitchChip)
{

    rtk_uint32 retVal;
    rtk_uint32 data, regValue;
    if((rtl8372n_getAsicReg(4, &regValue)) != RT_ERR_OK)
        return retVal;

    data = regValue >> 8;
    switch (data)
    {
        case 0x837300u:
            *pSwitchChip = CHIP_RTL8373;
            break;
        case 0x837200u:
            *pSwitchChip = CHIP_RTL8372;
            break;
        case 0x837370u:
            *pSwitchChip = CHIP_RTL8373N;
            break;
        case 0x837270u:
            *pSwitchChip = CHIP_RTL8372N;
            break;
        default:
            return RT_ERR_FAILED;
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_vlan_init
 * Description:
 *      Initialize VLAN.
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 * Note:
 *      VLAN is disabled by default. User has to call this API to enable VLAN before
 *      using it. And It will set a default VLAN(vid 1) including all ports and set
 *      all ports PVID to the default VLAN.
 */
rtk_api_ret_t rtk_vlan_init(void)
{
    rtk_uint32  retVal;
    switch_chip_t   switchChip;
    printk("Rtl837x Start Init Vlan\n");
    /* probe switch */
    if((retVal = rtk_switch_probe(&switchChip)) != RT_ERR_OK)
        return retVal;

    switch(switchChip)
    {
        case CHIP_RTL8372N:
            if((retVal = rtl8372n_vlan_init()) != RT_ERR_OK)
                return retVal;
            goto FINISH;
        case CHIP_RTL8372:
        case CHIP_RTL8373:
        case CHIP_RTL8373N:
            return RT_ERR_CHIP_NOT_SUPPORTED;
        default:
            return RT_ERR_CHIP_NOT_FOUND;
    }
FINISH:
    printk("Rtl837x Finish Init Vlan\n");
    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_init
 * Description:
 *      Set chip to default configuration environment
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_FAILED       - Failed
 *      RT_ERR_SMI          - SMI access error
 * Note:
 *      The API can set chip registers to default configuration for different release chip model.
 */
rtk_api_ret_t rtk_switch_init(void)
{
    rtk_uint32  retVal;
    switch_chip_t   switchChip;
    printk("Rtl837x Start Init switch\n");

    /* probe switch */
    if((retVal = rtk_switch_probe(&switchChip)) != RT_ERR_OK)
        return retVal;

    switch(switchChip)
    {
        case CHIP_RTL8372N:
            if((retVal = _rtk_switch_init_8372n()) != RT_ERR_OK)
                return retVal;
            break;
        case CHIP_RTL8372:
        case CHIP_RTL8373:
        case CHIP_RTL8373N:
            return RT_ERR_CHIP_NOT_SUPPORTED;
        default:
            return RT_ERR_CHIP_NOT_FOUND;
    }

    /* Set initial state */

    if((retVal = rtk_switch_initialState_set(INIT_COMPLETED)) != RT_ERR_OK)
        return retVal;

    printk("Rtl837x Finish Init switch\n");
    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_logicalPortCheck
 * Description:
 *      Check logical port ID.
 * Input:
 *      logicalPort     - logical port ID
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK       - Port ID is correct
 *      RT_ERR_FAILED   - Port ID is not correct
 *      RT_ERR_NOT_INIT - Not Initialize
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_logicalPortCheck(rtk_port_t logicalPort)
{
    if(init_state != INIT_COMPLETED)
        return RT_ERR_NOT_INIT;

    if(logicalPort >= RTK_SWITCH_PORT_NUM)
        return RT_ERR_FAILED;

    if(halCtrl->l2p_port[logicalPort] == 0xFF)
        return RT_ERR_FAILED;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_phyPortMask_get
 * Description:
 *      Get physical portmask
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      0x00                - Not Initialize
 *      Other value         - Physical port mask
 * Note:
 *
 */
rtk_uint32 rtk_switch_phyPortMask_get(void)
{
    if(init_state != INIT_COMPLETED)
        return 0x00; /* No port in portmask */

    return (halCtrl->phy_portmask);
}

/* Function Name:
 *      rtk_switch_isPortMaskValid
 * Description:
 *      Check portmask is valid or not
 * Input:
 *      pPmask       - logical port mask
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK           - port mask is valid
 *      RT_ERR_FAILED       - port mask is not valid
 *      RT_ERR_NOT_INIT     - Not Initialize
 *      RT_ERR_NULL_POINTER - Null pointer
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_isPortMaskValid(rtk_portmask_t *pPmask)
{
    if(init_state != INIT_COMPLETED)
        return RT_ERR_NOT_INIT;

    if(NULL == pPmask)
        return RT_ERR_NULL_POINTER;

    if( (pPmask->bits[0] | halCtrl->valid_portmask) != halCtrl->valid_portmask )
        return RT_ERR_FAILED;
    else
        return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_port_L2P_get
 * Description:
 *      Get physical port ID
 * Input:
 *      logicalPort       - logical port ID
 * Output:
 *      None
 * Return:
 *      Physical port ID
 * Note:
 *
 */
rtk_uint32 rtk_switch_port_L2P_get(rtk_port_t logicalPort)
{
    if(init_state != INIT_COMPLETED)
        return UNDEFINE_PHY_PORT;

    if(logicalPort >= RTK_SWITCH_PORT_NUM)
        return UNDEFINE_PHY_PORT;

    return (halCtrl->l2p_port[logicalPort]);
}

/* Function Name:
 *      rtk_switch_portmask_L2P_get
 * Description:
 *      Get physical portmask from logical portmask
 * Input:
 *      pLogicalPmask       - logical port mask
 * Output:
 *      pPhysicalPortmask   - physical port mask
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_NOT_INIT     - Not Initialize
 *      RT_ERR_NULL_POINTER - Null pointer
 *      RT_ERR_PORT_MASK    - Error port mask
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_portmask_L2P_get(rtk_portmask_t *pLogicalPmask, rtk_uint32 *pPhysicalPortmask)
{
    rtk_uint32 log_port, phy_port;

    if(init_state != INIT_COMPLETED)
        return RT_ERR_NOT_INIT;

    if(NULL == pLogicalPmask)
        return RT_ERR_NULL_POINTER;

    if(NULL == pPhysicalPortmask)
        return RT_ERR_NULL_POINTER;

    if(rtk_switch_isPortMaskValid(pLogicalPmask) != RT_ERR_OK)
        return RT_ERR_PORT_MASK;

    /* reset physical port mask */
    *pPhysicalPortmask = 0;

    RTK_PORTMASK_SCAN((*pLogicalPmask), log_port)
    {
        phy_port = rtk_switch_port_L2P_get((rtk_port_t)log_port);
        *pPhysicalPortmask |= (0x0001 << phy_port);
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_portmask_P2L_get
 * Description:
 *      Get logical portmask from physical portmask
 * Input:
 *      physicalPortmask    - physical port mask
 * Output:
 *      pLogicalPmask       - logical port mask
 * Return:
 *      RT_ERR_OK           - OK
 *      RT_ERR_NOT_INIT     - Not Initialize
 *      RT_ERR_NULL_POINTER - Null pointer
 *      RT_ERR_PORT_MASK    - Error port mask
 * Note:
 *
 */
rtk_api_ret_t rtk_switch_portmask_P2L_get(rtk_uint32 physicalPortmask, rtk_portmask_t *pLogicalPmask)
{
    rtk_uint32 log_port, phy_port;

    if(init_state != INIT_COMPLETED)
        return RT_ERR_NOT_INIT;

    if(NULL == pLogicalPmask)
        return RT_ERR_NULL_POINTER;

    RTK_PORTMASK_CLEAR(*pLogicalPmask);

    for(phy_port = halCtrl->min_phy_port; phy_port <= halCtrl->max_phy_port; phy_port++)
    {
        if(physicalPortmask & (0x0001 << phy_port))
        {
            log_port = rtk_switch_port_P2L_get(phy_port);
            if(log_port != UNDEFINE_PORT)
            {
                RTK_PORTMASK_PORT_SET(*pLogicalPmask, log_port);
            }
        }
    }

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_port_P2L_get
 * Description:
 *      Get logical port ID
 * Input:
 *      physicalPort       - physical port ID
 * Output:
 *      None
 * Return:
 *      logical port ID
 * Note:
 *
 */
rtk_port_t rtk_switch_port_P2L_get(rtk_uint32 physicalPort)
{
    if(init_state != INIT_COMPLETED)
        return UNDEFINE_PORT;

    if(physicalPort >= RTK_SWITCH_PORT_NUM)
        return UNDEFINE_PORT;

    return (halCtrl->p2l_port[physicalPort]);
}

ret_t rtk_portMib_read(rtk_uint32 port, rtk_uint32 mib_index, rtk_uint64 *counter_value)
{
    ret_t result; // x0

    rtk_uint32 reg_value; // [xsp+34h] [xbp+34h] BYREF
    rtk_uint32 v11; // [xsp+38h] [xbp+38h] BYREF
    rtk_uint32 v12; // [xsp+3Ch] [xbp+3Ch] BYREF

    reg_value = (32 * ((mib_index >> 1) & 0x3F)) | (2 * (port & 0xF)) | 1;
    result = rtl8372n_setAsicReg(0xF60u, reg_value);
    if ( result != RT_ERR_OK) return result;

    result = rtl8372n_getAsicRegBit(0xF60u, 0, &reg_value);
    if ( result != RT_ERR_OK) return result;

    rtk_uint32 retry_count = 101;
    while ( (reg_value & 1) != 0 )
    {
        if ( !--retry_count ) return RT_ERR_FAILED;
        result = rtl8372n_getAsicRegBit(0xF60u, 0, &reg_value);
        if ( result != RT_ERR_OK) return result;
    }

    result = rtl8372n_getAsicReg(0xF64u, &v12);
    if ( result != RT_ERR_OK) return result;

    result = rtl8372n_getAsicReg(0xF68u, &v11);
    if ( result != RT_ERR_OK) return result;

    if ( (mib_index - 0x5C > 3 && mib_index > 0xF) && mib_index - 0x62 > 3 )
    {
        if ( !(mib_index > 0x5B && mib_index - 0x60 > 1) || mib_index - 0x66 <= 1 )
        {
        if ( (mib_index & 1) != 0 )
            *counter_value = v11;
        else
            *counter_value = v12;
        }
    }
    else
    {
        *counter_value = (rtk_uint64)v11 | ((rtk_uint64)v12 << 32);
    }

    return RT_ERR_OK;
}

ret_t rtk_globalMib_rst(void)
{
    return rtl8372n_setAsicRegBit(0xF48u, 0, 1);
}

ret_t rtk_portMib_rst(rtk_uint32 port)
{
    return rtl8372n_setAsicReg(0xF4Cu, port | 0x10u);
}

char* rtk_chipid_to_chip_name(switch_chip_t id)
{
    switch (id)
    {
    case CHIP_RTL8373:
        return "RTL8373";
    case CHIP_RTL8372:
        return "RTL8372";
    case CHIP_RTL8224:
        return "RTL8224";
    case CHIP_RTL8373N:
        return "RTL8373N";
    case CHIP_RTL8372N:
        return "RTL8372N";
    case CHIP_RTL8224N:
        return "RTL8224N";
    case CHIP_RTL8366:
        return "RTL8366";
    default:
        return "Unknow";
    }
}